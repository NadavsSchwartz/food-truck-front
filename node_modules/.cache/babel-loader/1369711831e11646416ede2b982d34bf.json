{"ast":null,"code":"var _arity = require('./internal/_arity');\n\nvar _curry1 = require('./internal/_curry1');\n\nvar _has = require('./internal/_has');\n\nvar toString = require('./toString');\n/**\n * Creates a new function that, when invoked, caches the result of calling `fn`\n * for a given argument set and returns the result. Subsequent calls to the\n * memoized `fn` with the same argument set will not result in an additional\n * call to `fn`; instead, the cached result for that set of arguments will be\n * returned.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Function\n * @sig (*... -> a) -> (*... -> a)\n * @param {Function} fn The function to memoize.\n * @return {Function} Memoized version of `fn`.\n * @example\n *\n *      var count = 0;\n *      var factorial = R.memoize(n => {\n *        count += 1;\n *        return R.product(R.range(1, n + 1));\n *      });\n *      factorial(5); //=> 120\n *      factorial(5); //=> 120\n *      factorial(5); //=> 120\n *      count; //=> 1\n */\n\n\nmodule.exports = _curry1(function memoize(fn) {\n  var cache = {};\n  return _arity(fn.length, function () {\n    var key = toString(arguments);\n\n    if (!_has(key, cache)) {\n      cache[key] = fn.apply(this, arguments);\n    }\n\n    return cache[key];\n  });\n});","map":{"version":3,"sources":["/Users/nadavschwartz/Desktop/ReactProject/money-target/node_modules/ramda/src/memoize.js"],"names":["_arity","require","_curry1","_has","toString","module","exports","memoize","fn","cache","length","key","arguments","apply"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,mBAAD,CAApB;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,oBAAD,CAArB;;AACA,IAAIE,IAAI,GAAGF,OAAO,CAAC,iBAAD,CAAlB;;AACA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,YAAD,CAAtB;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAI,MAAM,CAACC,OAAP,GAAiBJ,OAAO,CAAC,SAASK,OAAT,CAAiBC,EAAjB,EAAqB;AAC5C,MAAIC,KAAK,GAAG,EAAZ;AACA,SAAOT,MAAM,CAACQ,EAAE,CAACE,MAAJ,EAAY,YAAW;AAClC,QAAIC,GAAG,GAAGP,QAAQ,CAACQ,SAAD,CAAlB;;AACA,QAAI,CAACT,IAAI,CAACQ,GAAD,EAAMF,KAAN,CAAT,EAAuB;AACrBA,MAAAA,KAAK,CAACE,GAAD,CAAL,GAAaH,EAAE,CAACK,KAAH,CAAS,IAAT,EAAeD,SAAf,CAAb;AACD;;AACD,WAAOH,KAAK,CAACE,GAAD,CAAZ;AACD,GANY,CAAb;AAOD,CATuB,CAAxB","sourcesContent":["var _arity = require('./internal/_arity');\nvar _curry1 = require('./internal/_curry1');\nvar _has = require('./internal/_has');\nvar toString = require('./toString');\n\n\n/**\n * Creates a new function that, when invoked, caches the result of calling `fn`\n * for a given argument set and returns the result. Subsequent calls to the\n * memoized `fn` with the same argument set will not result in an additional\n * call to `fn`; instead, the cached result for that set of arguments will be\n * returned.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Function\n * @sig (*... -> a) -> (*... -> a)\n * @param {Function} fn The function to memoize.\n * @return {Function} Memoized version of `fn`.\n * @example\n *\n *      var count = 0;\n *      var factorial = R.memoize(n => {\n *        count += 1;\n *        return R.product(R.range(1, n + 1));\n *      });\n *      factorial(5); //=> 120\n *      factorial(5); //=> 120\n *      factorial(5); //=> 120\n *      count; //=> 1\n */\nmodule.exports = _curry1(function memoize(fn) {\n  var cache = {};\n  return _arity(fn.length, function() {\n    var key = toString(arguments);\n    if (!_has(key, cache)) {\n      cache[key] = fn.apply(this, arguments);\n    }\n    return cache[key];\n  });\n});\n"]},"metadata":{},"sourceType":"script"}